# 编译课程设计申优文档

<center>17373384 王珊珊

[TOC]




## 手写编译器的感想

- 在做实验之前，首先我们需要熟悉我们所写的编译器支持的文法，这样不会让我们在debug的时候过于难顶。
- 写完后总体代码大约3000行上下，其中行数增量最多的一次是语法分析，但语法分析在逻辑上并不是最难的部分
- 留好接口和模块化设计会减小重构风险
- 建议用C++



## 词法分析

- 目的：识别单词，知道这是什么成分（标识符，保留字，整数，字符，字符串等等），按规定的格式输出单词信息

- 总体思路：不断循环读入文件内的字符，并根据当前字符能组合成什么来判定单词名称和类别码，直到读入EOF时停止。

- 难度：🌟



## 语法分析

- 目的：把词法分析识别出的单词拼接成连续的的语法成分，不论语义对错。使得程序能辨认出<xx声明>，<xx定义>，<赋值语句>，<表达式>等

- 总体思路：采用**递归下降分析法**一级一级向下分配任务，如果当读到的 sym 不符合该非终结符产生式的下一个成分，那么可以留一个接口 error()用于后续的报错。
  - 需要设置一些全局变量/容器，比如当前的 sym/已经识别出来的语法成分
  - 全篇代码有很多的 if else 语句
  - 理解了之后不会太难，主要是这一部分代码量极大，debug的时候可能会有一些细小的地方没注意到

- 难度：🌟🌟🌟



### 递归下降分析法

​	这里用的递归下降分析法是一种最左推导过程，是一种比较方便的不带回溯的自顶向下分析法，**对每一个非终结符号都设计一个函数（子程序）**一级一级向下分配任务，来完成对该非终结符号的分析和识别。

 - 如果在分析文法的时候发现产生式的 FIRST 集有交集，那么可以改写文法，把交集部分提取出来，再往后“偷看”一个成分来确定使用哪个产生式。
 - 或者先“将错就错”进入其中一个产生式非终结符的子程序，然后再通过多“偷看”几个符号来判断；给某些非终结符设计多个子程序，因为不带回溯的话，进入子程序时，开始的地方可能不同。

​	比如文法当中 <函数声明头部> 和 <变量声明> 都存在形如 int idenfr_name 的首部符号，那么这个时候，再读入一个 sym，若发现括号，那么可以判定为<函数声明头部>并进入<函数声明>子程序，然而这个时候已经读过括号了，正常顺序的<函数声明>是从 int idenfr_name 开始的，那么函数声明即可多设置一个子程序（函数）是从LPARENT (开始分析的。



## 错误处理（语义分析）

- 目的：语法分析并不能告诉目标机应该做什么，所以需要**语义分析来把无意义的句子变成有意义的句子**，那么在变成有意义的句子之前，我们需要先保证程序运行时**不能有一些原则性错误**，比如使用了未定义的变量名字，函数定义时返回值是char，而return 语句中返回了int 类型的变量，给 const 常量赋值等等。程序中出现这些行为时，需要报错。
- 总体思路：根据需要检查的错误类型，给全局常量、变量、每个函数包括 main 都建立了符号表。在每次声明标识符时检查重名和类型错误，在每次使用某个标识符时检查是否未定义等等。
  - 报错时，可以用到语法分析的时候留下的接口，传入错误类型常数即可
- 难度：🌟🌟🌟



### 符号表建立 - Func_attribute类设计

​	需要需符号表打交道的仅仅是语义分析和代码生成器，在本学期的实验中，错误处理显然需要用到符号表，所以理解为实验把代码生成和语义分析拆成了两次作业。

​	为了方便管理每个函数内部的参数列表，变量地址以及一些操作，这里设置了一个 class Func_attribute 管理程序中所有函数

```c++
class Func_attribute
{
   public:
    string Func_name;
    // 整个函数的常量，变量（包括参数）相对该函数的偏移，初始值为4，多出来0($sp)存$ra
    int func_sp_offset = 4; 
    int return_type; // 函数返回类型： 0 = void, 1 = int, 2 = char
    
    // 参数列表<para_name, para_type>, 要按顺序，所以用vector
    vector<pair<string, string>> para_table;
    // 下面的局部标识符 都可以和函数重名，但是互相之间不能重名
    // set 容器会自动去重， Map可以用哈希查找，变量和常量不需要研究顺序
    set<string> para_name; // 特别设置一个参数名，方便与常量和变量比较是否重定义

    // 常量列表<name, type>
    map<string, string> cons_table;
    // 变量列表, <name, <type, size>>,数组则size > 0
    map<string, pair<string, int>> vars_table;
    
    // 关于函数局部常量和变量
    map<string, int> int_cons_value; // <cons_name, Int value>
    map<string, char> char_cons_value; // <cons_name, char Value>
    map<string, int> vars_addr; // <name , address>
    // 参数对应的地址也视为普通变量使用
    
    Func_attribute();	// 构造器
    Func_attribute(string name, int type);
    int getType();
    
    void addPara(string type, string name); // 添加参数
    void addCons(string type, string name); // 添加常量
    void addVars(string type, string name, int arr_size); // 添加变量，含中间变量
    
    void allocVarAddr(string name, int size); // 给每一个变量都分配相对地址
    int getFuncSpOffset();	// 得到符号表最大相对地址，在函数调用时需要
};
```

在全局变量中则有这样一个定义：

```c++
map<string, Func_attribute> Func_attr;
// map<函数名称，函数属性>
```



## 中间代码生成

- 目的：在语法分析的同时生成中间代码，把读进来的东西转换成有意义的数字、字符串、类型等等，中间代码是编译器和运行目标机之间的“传话筒”，生成目标代码的时候，会通过分析中间代码来决定应该采取什么指令。
- 总体思路：采用四元式中间代码，设置了一个 class midCode，包括四元式四个部分的string以及代码类型。
- 难度：🌟🌟🌟🌟



### midCode类设计

​	对于不同种类的中间代码，有不同的构造函数

```c++
class midCode { // 由于是一个四元式，所以这里要设计一个midCode类能通用与所有中间四元式
  public:
    string result;  // 算术表达式中，result 表示左侧计算结果，跳转指令中，result表示要跳转到的标签名字
    string arg1;    //
    string op;
    string arg2;
    int type;   //  种类代号，详情见下面的表格
    
    midCode();
    // 分别有1～4个参数的构造器
    midCode(int type, string result, string arg1, string op, string arg2);
    midCode(int type, string result, string arg1, string op);
    midCode(int type, string result, string arg1);
    midCode(int type, string result); 
};
```

下面是我的中间代码设计分析表，显然不同类型的中间代码需要的参数个数不同

| Type | 语句种类                 | 代码示例              | result      | arg1       | op        | arg2     |
| ---- | :----------------------- | --------------------- | ----------- | ---------- | --------- | -------- |
| 1    | 二元运算赋值语句         | \#t1 = a / 2          | \#t1        | a          | /         | 2        |
| 1    |                          | t1 = 4+'a'            | \#t1        | 4          | +         | 'a'      |
|      |                          |                       |             |            |           |          |
| 2    | 右侧为数组元素           | \#t1 = m[k]           | \#t1        | m[k]       |           |          |
| 2    | 左侧为数组元素           | n[k] = \#t1           | n[k]        | \#t1       |           |          |
| 2    | 函数声明头               | int foo()             | int         | foo        |           |          |
| 2    | 调用进栈                 | push a                | push        | a          |           |          |
| 2    | 调用语句                 | call tar              | call        | tar        |           |          |
| 2    | 返回语句                 | ret x                 | ret         | x          |           |          |
| 2    | 无条件跳转               | goto for_end1         | goto        | for_end1   |           |          |
|      |                          |                       |             |            |           |          |
|      |                          |                       |             | **条件**   |           |          |
| 3    | 条件为假跳转             | BZ \#t1 for_end1      | BZ          | \#t1       | for_end1  |          |
| 3    | 条件为真跳转             | BNZ cond while_end    | BNZ         | cond       | while_end |          |
|      |                          |                       |             |            |           |          |
|      |                          | **默认size=0**        |             |            |           | 数组大小 |
| 4    | 变量定义                 | var int j             | var         | int        | j         | 0        |
|      | (有数组)                 | var char arr[10]      | var         | char       | arr       | 10       |
| 4    | 常量定义                 | const int x = 10      | const       | int        | x         | 10       |
|      |                          | const char y = 'h'    | const       | char       | y         | h        |
| 4    | 参数列表                 | para int a            | para        | int        | a         | 0        |
|      |                          |                       |             |            |           |          |
|      |                          |                       | **TmpReg**  |            |           |          |
| 5    | 条件(result存在 \#t1里)  | i <= 10               | \#t1        | i          | <=        | 10       |
| 5    |                          | x == y                | \#t2        | x          | ==        | y        |
| 5    | 条件仅有一个表达式       | cond                  | t3          | cond       |           |          |
|      |                          |                       |             |            |           |          |
|      | **写语句**               |                       |             | **字符串** | exp_type  | exp      |
| 6    | 仅有字符串写语句         | print "hello"         | print       | hello      | NONE      | NONE     |
| 6    | op代表表达式类型         | print t3              | print       | NONE       | NONE      | t3       |
| 6    | 类型默认为int,否则是char | print char t4         | print       | NONE       | char      | t4       |
| 6    | 表达式在最后             | print "hello" char t2 | print       | hello      | char      | t2       |
|      |                          |                       |             |            |           |          |
| 7    | 读语句(读 int 类型)      | scanf a               | scanf       | int        | a         |          |
| 7    | 读语句(读 char 类型)     | scanf ch              | scanf       | char       | ch        |          |
|      |                          |                       |             |            |           |          |
| 8    | If 标签                  | if_1_end:             | if_1_else:  |            |           |          |
| 8    | 函数头尾标签             | Func_1_head           | func_1_end  |            |           |          |
| 8    | for标签                  | For_1_begin           | For_1_begin |            |           |          |
| 8    | Do-while 标签            | do_1_begin            |             |            |           |          |
| 8    | whlie标签                | While_1_begin         |             |            |           |          |





## 目标代码生成

- 目的：根据中间代码生成目标机可运行的mips指令
- 总体思路：循环读入中间代码，然后根据不同中间代码类型，转换成不同mips
  - Type = 1，四则运算，相对简单
  - Type = 2，主要设计二元赋值（**有关数组寻址比较复杂**），参数传递，函数调用，返回语句需要好好设计
    - 数组寻址：出现左中括号 LBRACK [，分离出下标 index，和数组名，然后根据顺序判断它属于何种变量index*4后加上数组首地址即可得到该元素的地址，这也是为什么数组元素不放在四则运算的type = 1的中间代码里
    - 参数传递：由于程序中是先 push然后再 call，有可能出现参数嵌套了其他有返回值的函数调用的情况，这里push的时候把变量名存入一个vector, stack结构，读到 call 语句再依次把变量存到新的函数调用栈相对位置，此时需要使用到调用目标函数的最大偏移量，以及该参数相对于函数的偏移地址
    - 返回语句：如果返回类型不是void，那么把返回值存到 $v1中
  - Type = 3 或 5，与条件判断相关，用两个寄存器比较结果再装入新寄存器，branch类指令即可，注意跳转到的标签要把末尾冒号去掉
  - Type = 4，这个设计显然是多余的，do nothing 
  - Type = 6，先看字符串是否为空，然后表达式是否为空，然后把不为空的依次输出
  - Type = 7，看需要读入的变量类型是什么，选择恰当的syscall
  - Type = 8，直接原样输出标签
- 难度：Type2：🌟🌟🌟，其余部分难度：🌟🌟，但是debug较为复杂



## 代码优化

- 目的：使目标代码运行起来有更高效率
- 总体思路：减少中间变量的生成，减少与memory相关的指令，减少与jump相关的指令，具体操作见下面的分析
- 难度：🌟🌟🌟🌟，打分较难是因为数据流分析太复杂，搞不好就错了，所以没有做跨基本块的优化，下面只写出已经做了的优化



### 有关中间代码的优化

#### 表达式常数计算优化

源代码：

```c++
printf("3-8*(4/2 + 1)- -1*5 = ",3-8*(4/2 + 1)- -1*5);
```

我们的编译器把表达式的值算好，不用经过寄存器运算，中间代码已经直接变成了：

```
type = 6, print str3 NULL -16
```

在<表达式><项><因子>的子程序中，添加返回值，逐层返回字符串，判断如果两个操作数都是整数则直接运算





### 有关目标机对于Mips的代码优化

#### 计算、窥孔优化

- 四元式计算如果有常数，直接用addi
  - 如果减法用到了参数，不要用 subi 指令，用 addi 并把操作数改为相反数
- 条件比较不要用 sle 会拆成三条，用 sub, 然后与0比较的branch指令
- 数组下标寻址所有 mul xx,xx, 4 全都改成 sll 左移两位，不要乘法运算



#### 增加 s 寄存器组分配

- 中间变量（除了函数返回值）一次性存在s寄存器里面，不经过内存，$sx 的值不可变，使用一次后解绑失效

- 在每次使用变量的时候，要先判断是否能从寄存器里取数，不能的话再去内存相对地址寻找

- **注意，函数返回值 ret不要存在寄存器里，因为调用函数的时候跨越基本块可能会改动这个寄存器**

  

#### 增加 t 寄存器组分配（含循环优化）

- 扫描程序找出出现次数最多的标识符/for循环的归纳变量名字，并给他们分配临时寄存器，不超过5个
- 相似的，在每次使用变量的时候，要先判断是否能从t寄存器里取数，不能的话再去内存相对地址寻找
- **注意，在函数调用时，\$t 寄存器的值要一次存到栈里，返回后再从栈里恢复，\$sp多移动的量不超过32**



#### 函数传参数优化

- 锁定 a1 - a3 ，超过3个参数再存内存，否则从 a1, a2, a3调用参数值
- 每次调用函数的时候，先移动 sp 把 a1-a3的值存到栈里，回来的时候再恢复，storeA1, restoreA1 函数
- 有点像 \$t ，\$s 寄存器，可用这个寄存器直接代替这个值
- 同样地，在函数调用时，当前函数要把有几个参数，就把几个\$a1-\$a3存到栈里，超过3个则不需要处理



#### 